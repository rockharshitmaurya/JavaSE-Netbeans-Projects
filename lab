https://drive.google.com/folderview?id=1XcjmL4Hn0GVgLcgVe8cuKlxtEnIGvg2Y
	
 

S.no	Name of Experiment	Date	Signature
1	Introduction to basic Linux networking commands. (Commands like ipconfig, getmac, tracert, pathping, arp, ping, netstat, finger etc.)		
2	Implement bit stuffing and de-stuffing		
3	Write a program for hamming code generation for error detection and correction.		
4	Implement cyclic redundancy check (CRC).		
5	Write a program for congestion control using the leaky bucket algorithm.		
6	Implement Dijkstra’s algorithm to compute a shortest path through graph.		
7	Take a 64-bit plain text and encrypt the same using DES  algorithm.		
8	Using RSA algorithm encrypts a text data and decrypts the same.		
9	Implementation of the link state routing protocols.		
10	Implementation of LZW compression and decompression algorithms.		












hostname -i
User can find out all the aliases for the computer by using the command given below.
Assignment Topic:  Introduction to basic Linux networking commands. (Commands like ipconfig, getmac, tracert, pathping, arp, ping, netstat, finger etc.)

Submission:
Introduction to Networking Commands
The operating system consists of various built-in, command-line networking utilities that are used for network troubleshooting. We will see various networking commands which are most essentials for every network administrator.
There are various options a user can use with the Ping command.
Options are as follows-
Options	Description
target	This is the destination IP address or a hostname user want to ping.
-a	This option resolves the hostname of an IP address target.
-t	This ping command option will ping the target until you stop it by pressing Ctrl-C.
-n count	This option is used to set the number of ICMP Echo Requests to send, from 1 to 4294967295. If -n is not specified, the ping command will return 4 by default.
-l  size	This option is used to set the size, in bytes, of the echo-request packet from 32 to 65,527. If the -l option is not specified, the ping command will send a 32-byte echo request.
-s count	This option is used to report the time in the Internet Timestamp format that each echo request is received and an echo reply is sent. The maximum count value is 4, i.e. only the first four hops can be time stamped.
-r count	This command uses the ping command option to specify the number of hops between the source computer and the target computer. The maximum count value is 9; the Tracert command can also be used if the user wants to view all the hops between two devices.
-i TTL	This ping command option sets the Time to Live (TTL) value; the maximum value is 255.
-f	Use this ping command option to prevent ICMP Echo Requests from being fragmented by routers between the source and the target. The -f option is often used to troubleshoot Path Maximum Transmission Unit (PMTU) issues.
-w timeout	A timeout value must be specified while executing this ping command. It adjusts the amount of time in milliseconds. If the -w option is not specified, then the default timeout value of 4000 is set, which is 4 seconds.
-p	To ping a Hyper-V Network Virtualization provider address.
-S srcaddr	This option is used to specify the source address.
2. NetStat
Netstat is a Common TCP – IP networking command-line method present in most Windows, Linux, UNIX, and other operating systems. The netstat provides the statistics and information in the use of the current TCP-IP Connection network about the protocol.
 Popular Course in this category
There are various options a user can use with the Netstat command.
Options are as follows-
•	-a: This will display all connection and ports
•	-b: Shows the executable involved in each connection or hearing port
•	-e: This protocol will combine with the -sand display the ethernet statistics
•	-n: This will display the address and the port number in the form of numerical
•	-o: It will display the ID of each connection for the ownership process.
•	-r: It will display the routing table
•	-v: When used in combination with -b, the link or hearing port sequence for every executable is shown.
3. Ip Config
The command IP config will display basic details about the device’s IP address configuration. Just type IP config in the Windows prompt and the IP, subnet mask and default gateway that the current device will be presented. If you have to see full information, then type on command prompt config-all and then you will see full information. There are also choices to assist you in resolving DNS and DHCP issues.
4. Hostname
To communicate with each and other, the computer needs a unique address. A hostname can be alphabetic or alphanumeric and contain specific symbols used specifically to define a specific node or device in the network. For example, a hostname should have a domain name (TLD) of the top-level and a distance between one and 63 characters when used in a domain name system (DNS) or on the Internet.
Steps to Determine Your Computer’s Name
Open a terminal window and type the command given below.
hostname
It will provide the name of your computer. The first part of the result is the name of a computer and the second part is the name of the domain.
To get only  the computer name, run the following command:
hostname -s
The output will be localhost.
Similarly, if a user wants to find out which domain system is running, then use the following command.
hostname -d
The IP address for the hostname can also be retrieved by using the following command.”
hostname -a
5. Tracert
The tracert command is a Command Prompt command which is used to get the network packet being sent and received and the number of hops required for that packet to reach to target. This command can also be referred to as a traceroute. It provides several details about the path that a packet takes from the source to the specified destination.
The tracert command is available for the Command Prompt in all Windows operating systems.
The syntax for Tracert Command
tracert [-d] [-h MaxHops] [-w TimeOut]  target
There are various options the user can use with tracert command.
Options for tracert Command are as follows-
•	target: This is the destination, either an IP address or hostname.
•	–d: This option prevents Tracert from resolving IP addresses to hostnames to get faster results.
•	-h MaxHops: This Tracert option specifies the maximum number of hops in the search for the target. If the MaxHops option is not specified the target has not been found by 30 hops, then the tracert command will stop looking.
•	-w timeout: A timeout value must be specified while executing this ping command. It adjusts the amount of time in milliseconds.
6. Nslookup
The Nslookup, which stands for name server lookup command, is a network utility command used to obtain information about internet servers. It provides name server information for the DNS (Domain Name System), i.e. the default DNS server’s name and IP Address.
The syntax for Nslookup is as follows.
Nslookup
or
Nslookup [domain_name]
7. Route
In IP networks, routing tables are used to direct packets from one subnet to another. The Route command provides the device’s routing tables. To get this result, just type route print. The Route command returns the routing table, and the user can make changes by Commands such as Route Add, Route Delete, and Route Change, which allows modifying the routing table as a requirement.
8. ARP
ARP stands for Address Resolution Protocol. Although network communications can readily be thought of as an IP address, the packet delivery depends ultimately on the media access control (MAC). This is where the protocol for address resolution comes into effect. You can add the remote host IP address, which is an arp -a command, in case you have issues to communicate with a given host. The ARP command provides information like Address, Flags, Mask, IFace, Hardware Type, Hardware Address, etc.
9. Path Ping
We discussed the Ping command and the Tracert command. There are similarities between these commands. The pathping command which provides a combination of the best aspects of Tracert and Ping.
This command takes 300 seconds to gather statistics and then returns reports on latency and packet loss statistics at intermediate hops between the source and the target in more detail than those reports provided by Ping or Tracert commands.
The syntax for path ping is as follows:
path ping [-n] [-h] [-g <Hostlist>] [-p <Period>] [-q <NumQueries> [-w <timeout>] [-i<IPaddress>] [-4 <IPv4>] [-6 <IPv6>][<TargetName>]
•	N: Prevents path ping functioning from attempting to resolve routers’ IP addresses to their names.
•	-h MaxHops: This tracert option specifies the maximum number of hops in the search for the target. If the MaxHops option is not specified the target has not been found by 30 hops then the tracert command will stop looking.
•	-w timeout: A timeout value must be specified while executing this ping command. It adjusts the amount of time in milliseconds.
•	-ip<IPaddress>: Indicates the source address.
•	target: This is the destination IP address or a hostname user want to ping.














Assignment Topic:  ImplementingBit-Stuffing and De-Stuffing using C programming.

Submission:
Bit-Stuffing
#include<stdio.h>
#include<stdlib.h>
int main()
{
  char *p,*q;
  char temp
  char x[50];
  char y[50];
  int flag=0;

printf("Enter a binary number:\n");
scanf("%s",x);

  p=x;
  q=y;

  while(*p!='\0')
  {
    if(*p=='0')
    {
      *q=*p;
      q++;
      p++;
    }
    else
    {
while(*p=='1' && flag!=5)
      {
        flag++;
        *q=*p;
        q++;
        p++;
      }

      if(flag==5)
      {
        *q='0';
        q++;
      }
      flag=0;
    }
  }
  *q='\0';
printf("\n Stuffed Data:");
printf("\n%s",y);
    return 0;
}

Output:
 














De-Stuffing
#include<stdio.h>
#include<stdlib.h>
int main()
{
  char *p,*q;
  char temp
  char x[50];
  char y[50];
  int flag=0;

printf("Enter a binary number:\n");
scanf("%s",x);

  p=x;
  q=y;

  while(*p!='\0')
  {
    if(*p=='0')
    {
      *q=*p;
      q++;
      p++;
    }
    else
    {
while(*p=='1' && flag!=5)
      {
        flag++;
        *q=*p;
        q++;
        p++;
      }

      if(flag==5)
      {
        *q='0';
        q++;
      }
      flag=0;
    }
  }
  *q='\0';
  q=y;
  while(*p!='\0')
  {
    if(*p=='0')
    {
      *q=*p;
      q++;
      p++;
    }
    else
    {
while(*p=='1' && flag!=5)
      {
        count++;
        *q=*p;
        q++;
        p++;
      }
      if(flagt==5)
      {
        p++;
      }
      flag=0;
    }
  }
  *q='\0';
printf("\n De-stuffed data:");
printf("\n%s\n",y);
  return 0;
}







OUTPUT:
 














Stuffing
#include<stdio.h>
#include<stdlib.h>
int main()
{
  char *p,*q;
  char temp
  char x[50];
  char y[50];
  int flag=0;

printf("Enter a binary number:\n");
scanf("%s",x);

  p=x;
  q=y;

  while(*p!='\0')
  {
    if(*p=='0')
    {
      *q=*p;
      q++;
      p++;
    }
    else
    {
while(*p=='1' && flag!=5)
      {
        flag++;
        *q=*p;
        q++;
        p++;
      }

      if(flag==5)
      {
        *q='0';
        q++;
      }
      flag=0;
    }
  }
  *q='\0';
printf("\n Stuffed Data:");
printf("\n%s",y);

p=x;
q=y;
  while(*p!='\0')
  {
    if(*p=='0')
    {
      *q=*p;
      q++;
      p++;
    }
    else
    {
while(*p=='1' && flag!=5)
      {
        count++;
        *q=*p;
        q++;
        p++;
      }
      if(flagt==5)
      {
        p++;
      }
      flag=0;
    }
  }
  *q='\0';
printf("\n De-stuffed data:");
printf("\n%s\n",y);
  return 0;
}

Output:
 











Assignment Topic:  Write a program for hamming code generation for error detection and correction.
Submission:
#include<stdio.h>
 
void main() {
    int data[10];
    int dataatrec[10],c,c1,c2,c3,i;
 
    printf("Enter 4 bits of data one by one\n");
    scanf("%d",&data[0]);
    scanf("%d",&data[1]);
    scanf("%d",&data[2]);
    scanf("%d",&data[4]);
 
    //Calculation of even parity
    data[6]=data[0]^data[2]^data[4];
data[5]=data[0]^data[1]^data[4];
data[3]=data[0]^data[1]^data[2];
 
printf("\nEncoded data is\n");
for(i=0;i<7;i++)
        printf("%d",data[i]);
 
    printf("\n\nEnter received data bits one by one\n");
    for(i=0;i<7;i++)
        scanf("%d",&dataatrec[i]);
 
    c1=dataatrec[6]^dataatrec[4]^dataatrec[2]^dataatrec[0];
c2=dataatrec[5]^dataatrec[4]^dataatrec[1]^dataatrec[0];
c3=dataatrec[3]^dataatrec[2]^dataatrec[1]^dataatrec[0];
c=c3*4+c2*2+c1 ;
 
    if(c==0) {
printf("\nNo error while transmission of data\n");
    }
else {


printf("\nError on position %d",c);
    
printf("\nData sent : ");
        for(i=0;i<7;i++)
         printf("%d",data[i]);
        
printf("\nData received : ");
        for(i=0;i<7;i++)
         printf("%d",dataatrec[i]);
printf("\nCorrect message is\n");
 
//if errorneous bit is 0 we complement it else vice versa
if(dataatrec[7-c]==0)
dataatrec[7-c]=1;
        else
dataatrec[7-c]=0;
for (i=0;i<7;i++) {
printf("%d",dataatrec[i]);
}
}
}

Assignment Topic: Implement cyclic redundancy check (CRC)
Submission:
#include <iostream>
#include <conio.h>
using namespace std;
int main()
{
int i, j, k, l;
//Get Frame
int fs;
cout<< "\n Enter length of the data: ";
cin>> fs;
if (fs > 8)
{
cout<< "Invalid Input";
return 0;
}
int f[20];
cout<< "\n Enter the data:";
for (i = 0; i< fs; i++)
{
cin>> f[i];
}
//Get Generator
int gs;
cout<< "\n Enter the length of Generator(Divisor): ";
cin>>gs;
int g[20];

cout<< "\n Enter the Generator(Divisor):";
for (i = 0; i<gs; i++)
{
cin>> g[i];
}
cout<< "\n Sender Side:";
//Append 0's
int rs = gs - 1;
cout<< "\n Number of 0's to be appended: " <<rs;
for (i = fs; i< fs + rs; i++)
{
f[i] = 0;
}
int temp[20];
for (i = 0; i< 20; i++)
{
temp[i] = f[i];
}
cout<< "\n Message after appending 0's :";
for (i = 0; i< fs + rs; i++)
{
cout<< temp[i];
}
//Division
for (i = 0; i< fs; i++)
{
j = 0;
k = i;
//check whether it is divisible or not
if (temp[k] >= g[j])
{
for (j = 0, k = i; j <gs; j++, k++)
{
if ((temp[k] == 1 && g[j] == 1) || (temp[k] == 0 && g[j] == 0))
{
temp[k] = 0;
}
else
{
temp[k] = 1;
}
}
}
}
//CRC
int crc[15];
for (i = 0, j = fs; i<rs; i++, j++)
{
crc[i] = temp[j];
}
cout<< "\n CRC bits: ";
for (i = 0; i<rs; i++)
{
cout<<crc[i];
}
cout<< "\n Transmitted Data: ";
int tf[15];
for (i = 0; i< fs; i++)
{
tf[i] = f[i];
}
for (i = fs, j = 0; i< fs + rs; i++, j++)
{
tf[i] = crc[j];
}
for (i = 0; i< fs + rs; i++)
{
cout<<tf[i];
}
cout<< "\n Receiver side : ";
cout<< "\n Received Data: ";
for (i = 0; i< fs + rs; i++)
{
cout<<tf[i];
}
for (i = 0; i< fs + rs; i++)
{
temp[i] = tf[i];
}
//Division
for (i = 0; i< fs; i++)
{
j = 0;
k = i;
if (temp[k] >= g[j])
{
for (j = 0, k = i; j <gs; j++, k++)
{
if ((temp[k] == 1 && g[j] == 1) || (temp[k] == 0 && g[j] == 0))
{
temp[k] = 0;
}
else
{
temp[k] = 1;
}
}
}
}
cout<< "\n Remainder: ";
int rrem[15];
for (i = fs, j = 0; i< fs + rs; i++, j++)
{
rrem[j] = temp[i];
}
for (i = 0; i<rs; i++)
{
cout<<rrem[i];
}
int flag = 0;
for (i = 0; i<rs; i++)
{
if (rrem[i] != 0)
{
flag = 1;
}
}
if (flag == 0)
{
cout<< "\n Since Remainder is 0, hence the"
" Message Transmitted from Sender to Receiver is Correct";
}
else
{
cout<< "\n Since Remainder is not 0,"
" hence the Message Transmitted from Sender to Receiver contains Error";
}
getch();
}
Output
 
Assignment Topic: Write a program for congestion control using the leaky bucket algorithm.

Submission:
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>

#define NOF_PACKETS 10

intrand(int a)
{
intrn = (random() % 10) % a;
returnrn == 0 ? 1 :rn;
}

intmain()
{
intpacket_sz[NOF_PACKETS], i, clk, b_size, o_rate, p_sz_rm=0, p_sz, p_time, op;
for(i = 0; i<NOF_PACKETS; ++i)
packet_sz[i] = rand(6) * 10;
for(i = 0; i<NOF_PACKETS; ++i)
printf("\npacket[%d]:%d bytes\t", i, packet_sz[i]);
printf("\nEnter the Output rate:");
scanf("%d", &o_rate);
printf("Enter the Bucket Size:");
scanf("%d", &b_size);
for(i = 0; i<NOF_PACKETS; ++i)
    {
if( (packet_sz[i] + p_sz_rm) >b_size)
if(packet_sz[i] >b_size)/*compare the packet siz with bucket size*/
printf("\n\nIncoming packet size (%dbytes) is Greater than bucket capacity (%dbytes)-PACKET REJECTED", packet_sz[i], b_size);
else
printf("\n\nBucket capacity exceeded-PACKETS REJECTED!!");
else
        {
p_sz_rm += packet_sz[i];
printf("\n\nIncoming Packet size: %d", packet_sz[i]);
printf("\nBytes remaining to Transmit: %d", p_sz_rm);
p_time = rand(4) * 10;
printf("\nTime left for transmission: %d units", p_time);
for(clk = 10; clk<= p_time; clk += 10)
            {
sleep(1);
if(p_sz_rm)
                {
if(p_sz_rm<= o_rate)/*packet size remaining comparing with output rate*/
                        op = p_sz_rm, p_sz_rm = 0;
else
                        op = o_rate, p_sz_rm -= o_rate;
printf("\nPacket of size %d Transmitted", op);
printf("----Bytes Remaining to Transmit: %d", p_sz_rm);
                }
else
                {
printf("\nTime left for transmission: %d units", p_time-clk);
printf("\nNo packets to transmit!!");
                }
            }
        }
    }
}
 








Assignment Topic:  Implement Dijkstra's algorithm to compute a shortest path through graph.

Submission:
#include<stdio.h>
void main()
{
int path[5][5],i,j,min,a[5][5],p,st=1,ed=5,stp,edp,t[5],index;
printf("Enter the cost matrix\n");
for(i=1;i<=5;i++)
for(j=1;j<=5;j++)
scanf("%d",&a[i][j]);
printf("Enter the paths\n");
scanf("%d",&p);
printf("Enter possible paths\n");
for(i=1;i<=p;i++)
for(j=1;j<=5;j++)
scanf("%d",&path[i][j]);
for(i=1;i<=p;i++)
{
t[i]=0;
stp=st;
for(j=1;j<=5;j++)
{
edp=path[i][j+1];
t[i]=t[i]+a[stp][edp];
if(edp==ed)
break;
else
stp=edp;
}
}
min=t[st];index=st;
for(i=1;i<=p;i++)
{
if(min>t[i])
{
min=t[i];
index=i;
}
}
printf("Minimum cost %d",min);
printf("\n Minimum cost path ");
for(i=1;i<=5;i++)
{
printf("--> %d",path[index][i]);
if(path[index][i]==ed)
break;
}
}

Program Output:
Enter the cost matrix
1 2 3 4 5
1 2 3 4 5
1 2 3 4 5
1 2 3 4 5
1 2 3 4 5
Enter the paths
2
Enter possible paths
1 2 3 4 5
1 2 3 4 5
Minimum cost 14




















Assignment Topic:  Take a 64-bit plain text and encrypt the same using DES  algorithm
Submission:
DES uses a block size of 64 bits and a key size of 56 bits. That is, the plaintext is divided into blocks of length equal to 64 bits and the key injected in the algorithm to convert a plaintext block to ciphertext block is of length equal to 56 bits. If the total length of plaintext is not a multiple of 64, extra bits are appended at the end of plaintext to make its length equal to the multiple of 64.
Conceptually, encryption of plaintext to ciphertext in DES can be illustrated as:

 
Working of DES
Before proceeding with Data Encryption Standard, one must learn Feistel cipher in depth. It will make the understanding of DES much easier.
Steps performed in DES algorithm
1.	Plaintext is divided into 64-bit blocks.
2.	Initial Permutation is performed on 64-bit plaintext block.
3.	After Initial Permutation, block is divided into two halves of 32-bit each, Left Plain Text (L0) and Right Plain Text (R0).
4.	L and R go through 16 rounds; each round is fed with 48-bit subkey (refer Feistel Cipher for the concept of these subkeys). The round-key generator is an algorithm which is fed with an input of 56-bit key and it gives the output of 48-bit round-key. In the case of DES, the round-key algorithm is invoked 16 times (we will study this in detail hereafter).
5.	After 16 rounds, L and R are combined and then Final Permutation is performed on combined block of 64 bits.
6.	The result of this process produces a 64-bit ciphertext block.
7.	After all the blocks are processed using steps from ii to vi, ciphertext blocks are combined to get the full length ciphertext.
[Note: Here, permutation stands for the changing the arrangement, especially the linear order, of bits.]
 
DES Encryption
DES Analysis
The two desired properties, avalanche effect and completeness, of a cipher are satisfied by Data Encryption Standard algorithm. These two properties make cipher very strong.
•	Avalanche effect − A small change in plaintext results in the very great change in the ciphertext.
•	Completeness − Each bit of ciphertext depends on many bits of plaintext.
During the last few years, cryptanalysts have found some weaknesses in DES when key selected is a weak key. These keys shall be avoided. DES has proved to be a very well designed block cipher. There have been no significant cryptanalytic attacks on DES other than exhaustive key search.
Triple DES
In cryptography, Triple DES (3DES), officially the Triple Data Encryption Algorithm (TDEA or Triple DEA), is a symmetric-key block cipher, which applies the DES cipher algorithm three times to each data block.
Triple DES operates in three steps: Encrypt-Decrypt-Encrypt (EDE). It works by taking three 56-bit keys (K1, K2 and K3). Like DES, data is encrypted and decrypted in 64-bit chunks. The encryption-decryption process is as follows −

•	Encrypt the plaintext blocks using single DES with key K1.
•	Now decrypt the output of step 1 using single DES with key K2.
•	Finally, encrypt the output of step 2 using single DES with key K3.
•	The output of step 3 is the ciphertext.
•	Decryption of a ciphertext is a reverse process. User first decrypt using K3, then encrypt with K2, and finally decrypt with K1.
Triple DES systems are significantly more secure than single DES, but these are clearly a much slower process than encryption using single DES.
Let P be a block of plaintext, K a key, and C the corresponding block of ciphertext. For DES, C and P are each 64 bits, while K is 56 bits. Let the encryption of P with key K is denoted as:
C = E(P, K)
while the corresponding decryption is denoted as
P = D(C, K).
Note that for the same key, encryption and decryption are inverse operations, that is,
P = D(E(P,K),K) and C = E(D(C,K),K)
The logical approach to triple DES is defined as
C = E(D(E(P,K1),K2),K1).
Here, K1 = K3, i.e. triple DES only uses two keys. The reason for only using two keys is that 112 bits is sufficient, and three keys does not add much security.




















Assignment Topic: Using RSA algorithm encrypts a text data and decrypts the same.
Submission:
Working of RSA Algorithm
RSA involves use of public and private key for its operation. The keys are generated using the following steps:-
1.	Two prime numbers are selected as p and q
2.	n = pq which is the modulus of both the keys.
3.	Calculate totient = (p-1)(q-1)
4.	Choose e such that e > 1 and coprime to totient which means gcd (e, totient) must be equal to 1, e is the public key
5.	Choose d such that it satisfies the equation de = 1 + k (totient), d is the private key not known to everyone.
6.	Cipher text is calculated using the equation c = m^e mod n where m is the message.
7.	With the help of c and d we decrypt message using equation m = c^d mod n where d is the private key.
//Program for RSA asymmetric cryptographic algorithm
//for demonstration values are relatively small compared to practical application
 
#include<stdio.h>
#include<math.h>
 
//to find gcd
int gcd(int a, int h)
{
    int temp;
    while(1)
    {
        temp = a%h;
        if(temp==0)
        return h;
        a = h;
        h = temp;
    }
}
 
int main()
{
    //2 random prime numbers
    double p = 3;
    double q = 7;
    double n=p*q;
    double count;
    double totient = (p-1)*(q-1);
 
    //public key
    //e stands for encrypt
    double e=2;
 
    //for checking co-prime which satisfies e>1
    while(e<totient){
    count = gcd(e,totient);
    if(count==1)
        break;
    else
        e++;
    }
 
    //private key
    //d stands for decrypt
    double d;
 
    //k can be any arbitrary value
    double k = 2;
 
    //choosing d such that it satisfies d*e = 1 + k * totient
    d = (1 + (k*totient))/e;
    double msg = 12;
    double c = pow(msg,e);
    double m = pow(c,d);
    c=fmod(c,n);
    m=fmod(m,n);
 
    printf("Message data = %lf",msg);
    printf("\np = %lf",p);
    printf("\nq = %lf",q);
    printf("\nn = pq = %lf",n);
    printf("\ntotient = %lf",totient);
    printf("\ne = %lf",e);
    printf("\nd = %lf",d);
    printf("\nEncrypted data = %lf",c);
    printf("\nOriginal Message Sent = %lf",m);
 
    return 0;
}

Output :
Message data = 12.000000
Encrypted data = 3.000000
Original Message Sent = 12.000000


Assignment Topic: Implementation of the link state routing protocols.
Submission:
#include <stdio.h>
#define MAX         100                 // the max size of matrix
#define INF         9999        // infinity

typedef struct _gragh
{
	int vexnum; // number of nodes
	int matrix[MAX][MAX];
}Graph;


void dijkstra(Graph G,int start, int prev[],int dist[])
{
	int i,j,k;
	int min;
	int tmp;
	int flag[MAX]; //flag[i] = 1 represents I have get the shortest path from source to point i



	for(i=0;i<G.vexnum;i++){
		flag[i]=0;
		prev[i]=0;
		dist[i] = G.matrix[start][i];
		//printf("1 -> %d is %d\n",i+1,dist[i]);
	}

	//initialize source point
	flag[start] = 1;
	dist[start] = 0;


	for (i = 1; i<G.vexnum; i++)
	{

		
			min = INF;
			for (j = 0; j <G.vexnum; j++)
			{
					if (flag[j]==0 &&dist[j]<min)
					{
							min = dist[j];
							k = j;
					}
			}
		
			flag[k] = 1;
			printf("Next node = %d\n",k+1);

			
			for (j = 0; j <G.vexnum; j++)
			{
					tmp = (G.matrix[k][j]==INF ? INF : (min + G.matrix[k][j])); 
					if (flag[j] == 0 && (tmp<dist[j]) )
					{
							printf("Updating distance vector of node %d, New %d, Old %d\n",j+1,tmp,dist[j]);
							dist[j] = tmp;
							prev[j] = k;

					}
			}
			printf("\n");
	}
	printf("The final distances are:\n");
	for (i = 0; i<G.vexnum; i++)
					printf("1->%d = %d\n", i+1, dist[i]);

}




int main()
{
	//int nodes_num = 0; //number of nodes
	FILE *fp=NULL;
	Graph G;
	int i,j,c;
	int prev[MAX] = {0};
	int dist[MAX] = {0};

	//Graph initialization
	for(i=0;i<G.vexnum;i++)
	{
		for(j=0;j<G.vexnum;j++){
			G.matrix[i][j]=INF;
			if(i==j){
			G.matrix[i][j]=0;
			}
		}
	}

	//reading network from files
	if((fp=fopen("networkGraph.txt","r"))==NULL)
	{
		printf("file open erro!");
		return -1;
	}

	fscanf(fp,"%d",&(G.vexnum));
	printf("number of node is %d\n",G.vexnum);
	while(!feof(fp))
	{
		fscanf(fp,"%d,%d,%d",&i,&j,&c);
		G.matrix[i-1][j-1]=c;
		G.matrix[j-1][i-1]=c;
		//printf("%d to %d is %d\n", i,j,c);
	}

	for(i=0;i<G.vexnum;i++)
	{
		for(j=0;j<G.vexnum;j++){
			if(i!=j &&G.matrix[i][j]==0)
			G.matrix[i][j]=INF;

		}
		printf("\n");
	}

	//apply dijkstra method
	dijkstra(G,0,prev,dist);


	fclose(fp);
}

Output
Next node = 3
Updating distance vector of Node 4, New = 6, Old = 7
Updating distance vector of Node 5, New = 11, Old = infinity
Next node = 2
Updating distance vector of Node 5, New = 12, Old = 11
Updating distance vector of Node 6, New = 14, Old = infinity
Next node = 4
Updating distance vector of Node 5, New = 10, Old = 11
Next node = 5
Updating distance vector of Node 6, New = 12, Old = 14
Next node = 6
The final distances are:
1->1 = 0
1->2 = 5
1->3 = 3
1->4 = 6
1->5 = 10
1->6 = 12



























Assignment Topic: Implementation of LZW compression and decompression algorithms.

Submission:
#include <bits/stdc++.h>
using namespace std;
vector<int>encoding(string s1)
{
    cout<< "Encoding\n";
    unordered_map<string, int> table;
    for (int i = 0; i<= 255; i++) {
        string ch = "";
        ch += char(i);
        table[ch] = i;
    }
  
    string p = "", c = "";
    p += s1[0];
    int code = 256;
    vector<int>output_code;
    cout<< "String\tOutput_Code\tAddition\n";
    for (int i = 0; i< s1.length(); i++) {
        if (i != s1.length() - 1)
            c += s1[i + 1];
        if (table.find(p + c) != table.end()) {
            p = p + c;
        }
        else {
            cout<< p << "\t" << table[p] << "\t\t" 
                 << p + c << "\t" << code <<endl;
            output_code.push_back(table[p]);
            table[p + c] = code;
            code++;
            p = c;
        }
        c = "";
    }
    cout<< p << "\t" << table[p] <<endl;
    output_code.push_back(table[p]);
    return output_code;
}
  
void decoding(vector<int> op)
{
    cout<< "\nDecoding\n";
    unordered_map<int, string> table;
    for (int i = 0; i<= 255; i++) {
        string ch = "";
        ch += char(i);
        table[i] = ch;
    }
    int old = op[0], n;
    string s = table[old];
    string c = "";
    c += s[0];
    cout<< s;
    int count = 256;
    for (int i = 0; i<op.size() - 1; i++) {
        n = op[i + 1];
        if (table.find(n) == table.end()) {
            s = table[old];
            s = s + c;
        }
        else {
            s = table[n];
        }
        cout<< s;
        c = "";
        c += s[0];
        table[count] = table[old] + c;
        count++;
        old = n;
    }
}
int main()
{
  
    string s = "WYS*WYGWYS*WYSWYSG";
    vector<int>output_code = encoding(s);
    cout<< "Output Codes are: ";
    for (int i = 0; i<output_code.size(); i++) {
        cout<<output_code[i] << " ";
    }
    cout<<endl;
    decoding(output_code);
}

Output:
Encoding
String    Output_Code    Addition
W    87        WY    256
Y    89        YS    257
S    83        S*    258
*    42        *W    259
WY    256        WYG    260
G    71        GW    261
WY    256        WYS    262
S*    258        S*W    263
WYS    262        WYSW    264
WYS    262        WYSG    265
G    71
Output Codes are: 87 89 83 42 256 71 256 258 262 262 71 

Decoding
WYS*WYGWYS*WYSWYSG

